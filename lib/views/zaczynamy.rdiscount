#### {% title "Fortunka v0.0" %}

# „Fortunka” v0.0

<blockquote>
 <p>
  {%= image_tag "/images/ken-arnold.jpg", :alt => "[Ken Arnold]" %}
 </p>
 <p>A fortune program first appeared in Version 7 Unix. The most common
  version on modern systems is the BSD fortune, originally written by
  Ken Arnold. [source Wikipedia]</p>
</blockquote>

Pierwszą aplikacją, którą napiszemy w Ruby on Rails będzie
[Fortunka](http://en.wikipedia.org/wiki/Fortune_(Unix\))
z możliwością dopisywania komentarzy.

Czym jest Ruby on Rails:
„Ruby on Rails is an **MVC** framework for web application development.”

## MVC ≡ Model / Widok / Kontroler

„MVC is sometimes called a design pattern, but thats not technically
accurate. It is in fact an amalgamation of design patterns (sometimes
referred to as an architecture pattern).”

<blockquote>
 {%= image_tag "/images/frederick-brooks.jpg", :alt => "[Frederick P. Brooks, Jr.]" %}
 <p>To see what rate of progress one can expect in software technology,
  let us examine the difficulties of that technology. Following
  Aristotle, I divide them into <b>essence</b>, the difficulties inherent in
  the nature of software, and <b>accidents</b>, those difficulties that today
  attend its production but are not inherent.</p>
 <p>I believe the hard part of building software to be the specification,
   design, and testing of this conceptual construct, not the labor of
   representing it and testing the fidelity of the representation. We
   still make syntax errors, to be sure; but they are fuzz compared with
   the conceptual errors in most systems.
 </p>
 <p class="author">— Frederick P. Brooks, Jr.</p>
</blockquote>

**Użycie MVC w aplikacji webowej**
[(źródło)](http://betterexplained.com/articles/intermediate-rails-understanding-models-views-and-controllers/)

{%= image_tag "/images/mvc-rails.png", :alt => "[MVC w Rails]" %}

E. Gamma, R. Helm, R. Johnson, J. Vlissides.
[Wzorce Projektowe](http://www.wnt.com.pl/product.php?action=0&prod_id=986):
„Model jest obiektem aplikacji. Widok jego ekranową reprezentacją,
zaś Koordynator definiuje sposób, w jaki interfejs użytkownika
reaguje na operacje wykonywane przez użytkownika. Przed MVC
w projektach interfejsu użytkownika te trzy obiekty były na ogół
łączone. **MVC rozdziela je, aby zwiększyć elastyczność i możliwość
wielokrotnego wykorzystywania.**”

I jeszcze jeden cytat:
„MVC rozdziela widoki i model, ustanawiając między nimi protokół
powiadamiania. Widok musi gwarantować, że jego wygląd odzwierciedla
stan modelu. Gdy tylko dane modelu się zmieniają, model powiadamia
zależące od niego widoki. Dzięki temu każdy widok ma okazję do
uaktualnienia się. To podejście umożliwia podłączenie wielu widoków do
jednego modelu w celu zapewnienia różnych prezentacji tych danych.
Można także tworzyć nowe widoki dla modelu bez potrzeby modyfikowania
go.”


# Fortunka

Fortune (Unix) to program „which will display quotes or
witticisms. Fun-loving system administrators can add fortune to users'
.login files, so that the users get their dose of wisdom each time
they log in.”

Opis funkcjonalności aplikacji webowej *Fortunka*:

* **CRUD** na fortunkach (co to znaczy?)
* do każdej fortunki będzie można dopisać komentarz

Na razie tyle. Później dodamy jeszcze kilka funkcji.

Zaczynamy od wygenerowania rusztowania aplikacji i przejścia do
katalogu z wygenerowanym rusztowaniem:

    rails new fortunka
    cd fortunka

Z czego składa się wygenerowane rusztowanie?

## Bundler

Będziemy korzystać z gotowych gemów (bibliotek) języka Ruby.
Gemami użytymi w Fortunce zarządzamy za pomocą programu
*bundler*. Instrukcje dla tego programu umieszczamy
w pliku *Gemfile*.

Zaczynamy od modyfikacji wygenerowanego pliku:

    :::ruby Gemfile
    source 'http://rubygems.org' # domyślna wartość
    gem 'rails' # usuwamy numer wersji; będziemy korzystać zawsze z ostatniej
    # dla odważnych – można pobrać wersję „(bleeding?) edge”
    # gem 'rails', :git => 'git://github.com/rails/rails.git'
    gem 'sqlite3'
    gem 'thin' # będziemy używać serwera „thin” zamiast serwera „webrick”
    # konfigurujemy irb ($HOME/.irbrc)
    group :development do
      gem 'nifty-generators'
      gem 'wirble'
      gem 'hirb'
    end

Z gemów Wirble i Hirb będziemy korzystać tylko w trybie development.

Na koniec instalujemy gemy i sprawdzamy, gdzie zostały zainstalowane
w systemie:

    bundle install --path=$HOME/.gems
    bundle show rails

**Uwaga:** Opcji `--path` używamy tylko raz. Następnym razem
uruchamiamy program *bundle* bez tej opcji.


## Serwer WWW

W trakcie pisania kodu aplikację uruchamiamy w trybie **development**.
Możemy to zrobić na kilka sposobów. Poniżej podaję trzy:

<pre>rails server thin -p <i>numer portu</i>
passenger start -p <i>numer portu</i>
thin --rackup config.ru start -p <i>numer portu</i>
</pre>


## Co to jest REST?

<blockquote>
{%= image_tag "/images/hfrails_cover.png", :alt => "[Head First Rails]" %}
<p>
  If you use REST, your teeth will be brighter,
  your life will be happier,
  and all will be goodnes and sunshine with the world.
</p>
<p class="author">– David Griffiths</p>
</blockquote>

W aplikacjach Rails prawie zawsze korzystamy z *REST*, czyli
z **Represenational State Transfer**.

Dlaczego? Częściowo wyjaśnia to ten cytat:
„RESTful design really means designing your applications
to work the way the web was **originally** meant to look.”

Podstawy REST:

1. Dane są zasobami (ang. *resources*). Fortunka to zbiór
   cytatów, dlatego cytaty są *resources*.
2. Każdy zasób ma swój unikalny URI.
3. Na zasobach można wykonywać cztery podstawowe operacje
   Create, Read, Update i Delete
   (zwykle skracane do *CRUD*).
4. Klient i serwer komunikują się ze sobą korzystając
   protokołu bezstanowego. Oznacza to, że klient
   zwraca się z żądaniem do serwera. Serwer odpowiada i
   cała konwersacja się kończy.


<blockquote>
<p>RFC2235:
  <a href="http://www.faqs.org/rfcs/rfc2235.html">Hobbes’ Internet Timeline</a>
</p>
<p>RFC2334:
  <a href="http://www.faqs.org/rfcs/rfc2324.html">Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</a>
</p>
</blockquote>


## Korzystamy z generatora scaffold

Generujemy rusztowanie dla zasobu (ang. *resource*) *fortune*:

    rails generate scaffold fortune body:text

Co wygenerował generator?

Aby utworzyć bazę danych o nazwie podanej w pliku
*config/database.yml* oraz tabelę zdefiniowaną w pliku
*db/migrate/20100624132312_create_fortunes.rb*
wykonujemy polecenie:

    rake db:migrate

Generator dopisał do pliku z routingiem *config/routes.rb*:

    resources :fortunes

Aby obejrzeć routing aplikacji wykonujemy polecenie:

    rake routes

Jak należy odczytywać, to co zostało wypisane przez to polecenie?

Jeszcze jeden rzut oka na MVC w kontekście zasobów, na przykładzie
zasobu *User*.

{%= image_tag "/images/mvc_detailed.png", :alt => "[MVC w Rails]" %}

[Źródło](http://www.railstutorial.org/images/figures/mvc_detailed-full.png)


## Korzystamy z generatora nifty:scaffold

W pliku *Gemfile* umieścilismy wcześniej gem *nifty-generators*.
Po zainstalowaniu tego gemu, polecenie *rails generators*
pokazuje cztery nowe generatory:

      nifty:authentication
      nifty:config
      nifty:layout
      nifty:scaffold

Użyjemy dwa z nich:

    rails generate nifty:layout
    rails generate nifty:scaffold ...

ale najpierw wykonamy UNDO, tego co wygenerował *scaffold*:

    rails destroy ...

TODO:

* dopisujemy do Gemfile gem *nifty-generators*
* różnice w wygenerowanym kodzie
* dlaczego *nifty:scaffold*

Kontrolery Rails wygenerowane przez:

<ul>
  <li>{%= link_to "scaffold", "/rails3/scaffold/posts_controller.rb" %}
  <li>{%= link_to "nifty:scaffold", "/rails3/nifty-generators/comments_controller.rb" %}
</ul>

Porównać. Dlaczego będziemy korzystać z nifty:scaffold?
