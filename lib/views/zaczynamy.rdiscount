#### {% title "Zaczynamy" %}

# Zaczynamy

Pierwszą aplikacją Rails, którą utworzymy będzie Fortunka
z możliwością dopisywania komentarzy.

Czym jest Ruby on Rails:
„Ruby on Rails is an **MVC** framework for web application development.”


<blockquote>
 {%= image_tag "/images/frederick-brooks.jpg", :alt => "[Frederick P. Brooks, Jr.]" %}
 <p>To see what rate of progress one can expect in software technology,
  let us examine the difficulties of that technology. Following
  Aristotle, I divide them into <b>essence</b>, the difficulties inherent in
  the nature of software, and <b>accidents</b>, those difficulties that today
  attend its production but are not inherent.</p>
 <p>I believe the hard part of building software to be the specification,
   design, and testing of this conceptual construct, not the labor of
   representing it and testing the fidelity of the representation. We
   still make syntax errors, to be sure; but they are fuzz compared with
   the conceptual errors in most systems.
 </p>
 <p class="author">— Frederick P. Brooks, Jr.</p>
</blockquote>

## MVC ≡ Model / Widok / Kontroler

„MVC is sometimes called a design pattern, but thats not technically
accurate. It is in fact an amalgamation of design patterns (sometimes
referred to as an architecture pattern).”

**Użycie MVC w aplikacji webowej**
[(źródło)](http://betterexplained.com/articles/intermediate-rails-understanding-models-views-and-controllers/)

{%= image_tag "/images/mvc-rails.png", :alt => "[MVC w Rails]" %}

E. Gamma, R. Helm, R. Johnson, J. Vlissides.
[Wzorce Projektowe](http://www.wnt.com.pl/product.php?action=0&prod_id=986):
„Model jest obiektem aplikacji. Widok jego ekranową reprezentacją,
zaś Koordynator definiuje sposób, w jaki interfejs użytkownika
reaguje na operacje wykonywane przez użytkownika. Przed MVC
w projektach interfejsu użytkownika te trzy obiekty były na ogół
łączone. **MVC rozdziela je, aby zwiększyć elastyczność i możliwość
wielokrotnego wykorzystywania.**”

I jeszcze jeden cytat:
„MVC rozdziela widoki i model, ustanawiając między nimi protokół
powiadamiania. Widok musi gwarantować, że jego wygląd odzwierciedla
stan modelu. Gdy tylko dane modelu się zmieniają, model powiadamia
zależące od niego widoki. Dzięki temu każdy widok ma okazję do
uaktualnienia się. To podejście umożliwia podłączenie wielu widoków do
jednego modelu w celu zapewnienia różnych prezentacji tych danych.
Można także tworzyć nowe widoki dla modelu bez potrzeby modyfikowania
go.”


<blockquote>
 <p>
  {%= image_tag "/images/ken-arnold.jpg", :alt => "[Ken Arnold]" %}
 </p>
 <p>A fortune program first appeared in Version 7 Unix. The most common
  version on modern systems is the BSD fortune, originally written by
  Ken Arnold. [source Wikipedia]</p>
</blockquote>

# Fortunka

Fortune (Unix) to program „which will display quotes or
witticisms. Fun-loving system administrators can add fortune to users'
.login files, so that the users get their dose of wisdom each time
they log in.”

Opis funkcjonalności aplikacji webowej *Fortunka*:

* **CRUD** na fortunkach (co to znaczy?)
* do każdej fortunki będzie można dopisać komentarz

Na razie tyle. Później dodamy jeszcze kilka funkcji.

Zaczynamy od wygenerowania rusztowania aplikacji i przejścia do
katalogu z wygenerowanym rusztowaniem:

    rails new fortunka
    cd fortunka

Z czego składa się wygenerowane rusztowanie?

## Bundler

Będziemy korzystać z gotowych gemów (bibliotek) języka Ruby.
Gemami użytymi w Fortunce zarządzamy za pomocą programu
*bundler*. Instrukcje dla tego programu umieszczamy
w pliku *Gemfile*.

Zaczynamy od modyfikacji wygenerowanego pliku:

    :::ruby Gemfile
    source 'http://rubygems.org'
    gem 'rails'
    # or use stable branch
    #   gem 'rails', :git => 'git://github.com/rails/rails.git', :branch => '3-0-stable'
    # or bundle edge Rails    
    #   gem 'rails', :git => 'git://github.com/rails/rails.git'
    gem 'sqlite3-ruby', :require => 'sqlite3'
    # use thin / unicorn as web server
    gem 'thin'
    gem 'unicorn'
    # configure irb, see ~/.irbrc
    group :development do
      gem 'wirble'
      gem 'hirb'
    end

Z gemów Wirble i Hirb będziemy korzystać tylko w trybie development.

Na koniec instalujemy gemy i sprawdzamy, gdzie zostały zainstalowane
w systemie:

    bundle install
    bundle show rails


## Serwer WWW

W trakcie pisania kodu aplikację uruchamiamy w trybie **development**.
Możemy to zrobić na kilka sposobów:

<pre>rails server thin -p <i>numer portu</i>
passenger start -p <i>numer portu</i>
unicorn -p <i>numer portu</i>
thin --rackup config.ru start -p <i>numer portu</i>
</pre>


## Co to jest REST?

<blockquote>
{%= image_tag "/images/hfrails_cover.png", :alt => "[Head First Rails]" %}
<p>
  If you use REST, your teeth will be brighter,
  your life will be happier,
  and all will be goodnes and sunshine with the world.
</p>
<p class="author">– David Griffiths</p>
</blockquote>

Dłuższy cytat: „**REST** stands for **Represenational State Transfer**
\[…hmm?!…\] RESTful design really means designing your applications
to work the way the web was **originally** meant to look.”

Podstawy REST:

1. Dane są zasobami (ang. *resources*). Fortunka to zbiór
   cytatów, dlatego cytaty są *resources*.
2. Każdy zasób ma swój unikalny URI.
3. Na zasobach można wykonywać cztery podstawowe operacje
   Create, Read, Update i Delete 
   (zwykle skracane do *CRUD*).
4. Klient i serwer komunikują się ze sobą korzystając
   protokołu bezstanowego. Oznacza to, że klient 
   zwraca się z żądaniem do serwera. Serwer odpowiada i
   cała konwersacja się kończy.


## Korzystamy z generatora „resource”

Generujemy kod dla zasobu (ang. *resource*) *fortune*:

    rails generate resource fortune body:text

Co wygenerował generator?

Aby utworzyć bazę danych o nazwie podanej w pliku
*config/database.yml* oraz tabelę zdefiniowaną w pliku
*db/migrate/20100624132312_create_fortunes.rb*
wykonujemy polecenie:

    rake db:migrate

W bazie nie ma jeszcze fortunek. Na tym etapie pisania aplikacji, do
bazy możemy dodać kilka fortunek na dwa sposoby:

* dodając je z konsoli
* wpisując je w pliku *db/seed.rb* i wykonując polecenie `rake seed`

Zobacz też [Easy environment specific seed files in Rails 3](http://www.codeofficer.com/blog/entry/easy_environment_specific_seed_files_in_rails_3/).

Oczywiście, w gotowych aplikacjach rekordy do bazy dodajemy
korzystając z formularzy.
 
Generator dopisał do pliku z routingiem *config/routes.rb*:

    resources :fortunes

Aby obejrzeć routing aplikacji wykonujemy polecenie:

    rake routes

Jak należy odczytywać, to co zostało wypisane przez to polecenie?

Jeszcze jeden rzut oka na MVC w kontekście zasobów, na przykładzie
zasobu *User*.

{%= image_tag "/images/mvc_detailed.png", :alt => "[MVC w Rails]" %}

[Źródło](http://www.railstutorial.org/images/figures/mvc_detailed-full.png)


### Kontroler

Generator utworzył plik *app/controllers/fortunes_controller.rb*.
zawierający pusty kontroler *FortunesController*.
*FortunesController* jest podklasą *ApplicationController*.

<blockquote>
 <h2>Rails 3 controllers</h2>
 <ul>
   <li>{%= link_to "nifty:scaffold", "/rails3/nifty-generators/comments_controller.rb" %}
   <li>{%= link_to "scaffold", "/rails3/scaffold/posts_controller.rb" %}
   <li>{%= link_to "respond_with", "/rails3/respond-with/products_controller.rb" %}
 </ul>
</blockquote>

Każdy *resource controller* musi definiować **7 metod** o nazwach:

* *index*, *show* 
* *new*, *create* 
* *edit*, *update*
* *destroy*

Przykładowe implementacje można podejrzeć klikając linki po prawej.


## Akcje i szablony

Zwyczajowo *index* kojarzymy kompletną listę zasobów. 

Uruchamiamy serwer www i wchodzimy na stronę z fortunkami:

    http://localhost:3000/fortunes

Co powinno się wydarzyć? 

    Unknown action
    The action 'index' could not be found for FortunesController

Oznacza to, że powinniśmy napisać metodę *index*.

    :::ruby app/controllers/fortunes_controller.rb
    class FortunesController < ApplicationController
      respond_to :html
      def index
        @fortunes = Fortune.order("created_at desc")
        respond_with @fortunes
      end
    end

Więcej info o parze **respond_to** i **respond_with**:

* [Controllers in Rails 3](http://asciicasts.com/episodes/224-controllers-in-rails-3)
* [ActionController::Responder](http://github.com/rails/rails/blob/master/actionpack/lib/action_controller/metal/responder.rb)
* [One in Three: Inherited Resources, Has Scope and Responders](http://blog.plataformatec.com.br/tag/respond_with/)
  – zawiera opis *FlashResponder* (korzysta z **I18N**) oraz *HttpCacheResponder*

Odświeżamy stronę:

    http://localhost:3000/fortunes

Teraz serwer zgłasza wyjątek i odpowiada (*response*) komunikatem
o błędzie:

    Action Controller: Exception caught
    
    Template is missing
    Missing template fortunes/index with 
      {:locale=>[:en, :en], :handlers=>[:builder, :rjs, :erb, :rhtml, :rxml], 
      :formats=>[:html]} in view paths ".../app/views"

Nie pozostaje nam nic innego jak utworzyć szablon **powiązany**
z metodą *index*:

    :::html_rails app/views/fortunes/index.html.erb
    <h1>Fortunki</h1>
    <% @fortunes.each do |fortune| %>
    <p><%= fortune.body %></p>
    <% end %>

Jeszcze raz wchodzimy na stronę *index*. Teraz powinniśmy zobaczyć
widok wygenerowany z powyższego szablonu.

Powyżej mamy przykład szablonu *ERB* (ang. *embeded ruby*).

Co może oznaczać zwrot: **convention over configuration**?
Co to jest **ORM** – mapowanie obiektów na relacje
i relacji na obiekty?


### Tworzymy szablon „new” i metodę „new”

Jest obojętne czy najpierw utworzymy szablon, a później
metodę metodę powiązaną z tym szablonem czy odwrotnie.

Teraz, dla przykładu zaczniemy od szablonu *new.html.erb*.
Szablon powinien zawierać formularz umożliwiający
wpisanie nowej fortunki.

    :::html_rails app/views/fortunes/new.html.erb
    <h1>Nowa fortunka</h1>
    <%= form_for(Fortune.new) do |form| %>
    <p>
      <%= form.text_area :body %><br/>
      <%= form.submit %>
    <p>
    <% end %>

Powyżej korzystamy z **metody pomocniczej** (ang. *helper method*)
o nazwie *form_for*.

Ponieważ korzystamy z routingu REST, więc aby utworzyć
nową fortunkę wchodzimy na następujący url:

    http://localhost:3000/fortunes/new

Widzimy stronę z formularzem. Kilkamy przycisk *Create Fortune*.
Daje to następujący błąd:

    Unknown action
    The action 'create' could not be found for FortunesController

**Oczywiście** oznacza to, że powinniśmy zaimplementować metodę
*create*:

    :::ruby app/controllers/fortunes_controller.rb
    def create
      @fortune = Fortune.create(params[:fortune])
      respond_with @fortune # odpowiadamy polimorficznie
    end

Dlaczego wykonujemy *redirect_to*? Co oznacza tutaj *polimorficznie*?

Na razie zakładamy, że użytkownik nie oszukuje i wpisuje w formularz
to co jest proszony, a nie na przykład złośliwy kod. 
Walidacją tego co wpisuje użytkownik zajmiemy się później.

Po kliknięciu przycisku „Create Fortune”, nowa fortunka 
jest zapisywana w tabeli, a my zostajemy przekierowani na stronę
*show*, której nie ma:

    Unknown action
    The action 'show' could not be found for FortunesController

Nie napisaliśmy też metody *show*. Robimy to teraz.

Czytamy to co zostało wypisane na konsoli i piszemy metodę *show*:

    :::ruby app/controllers/fortunes_controller.rb
    def show  
      @product = Product.find(params[:id])  
      respond_with @product # odpowiadamy polimorficznie
    end 

Szablon też piszemy „od ręki”:

    :::html_rails app/views/fortunes/show.html.erb
    <p>
      <b>Body:</b>
      <%= @fortune.body %>
    </p>


## Poprawki w layoucie

Zwyczajowo, po zapisaniu rekordu w bazie, na stronie na którą
zostajemy przekierowani, jest wyświetlany komunikat w stylu:
*Utworzono nowy rekord Fortune*.

Railsy do wyświetlania takich komunikatów korzystają z **flash messages** 
Szablon do wyświetlania flash messages umieszczamy layoucie.

Przy okazji: co to jest **layout**? Jak to przetłumaczyć na język polski?

Nowy layout utworzymy w pokrętny sposób. Skorzystamy z gotowca
wygenerowanego przez generator *nifty:layout*. 

Dopiszmy w pliku *Gemfile*:

    gem 'nifty-generators'

i wykonajmy polecenie

    bundle install

Teraz polecenie:

    rails generate

wypisze coś takiego:

    Nifty:
      nifty:authentication
      nifty:config
      nifty:layout
      nifty:scaffold

Wykonanie polecenia:

    rails generate nifty:layout 

spowoduje wygenerowanie layoutu z flash messages:

    :::html_rails app/views/layouts/application.html.erb
    <!DOCTYPE html>
    <html>
      <head>
        <title><%= content_for?(:title) ? yield(:title) : "Untitled" %></title>
        <%= stylesheet_link_tag "application" %>
        <%= javascript_include_tag :defaults %>
        <%= csrf_meta_tag %>
        <%= yield(:head) %>
      </head>
      <body>
        <div id="container">
          <% flash.each do |name, msg| %>
            <%= content_tag :div, msg, :id => "flash_#{name}" %>
          <% end %>
          <%= content_tag :h1, yield(:title) if show_title? %>
          <%= yield %>
        </div>
      </body>
    </html>


## Responders

Problem:

* gdzie wpisać komunikaty flash? 
* co z i18n?

Eleganckie rozwiązanie obu probelmów przedstawił 
[José Valim[(http://blog.plataformatec.com.br/tag/respond_with/).

Zaczynamy od:

    rails destroy controller fortune

Następnie dopisujemy gem do *Gemfile*:

    gem 'responders'

i wykonujemy:

    bundle install

Teraz możemy skorzystać z nowych generatorów:

    rails generate responders:install
    rails generate responders_controller fortune

Niestety generator nadpisał utworzone przez nas pliki. 
Dopóty nie zostanie to poprawione, dopóki czeka nas poprawianie
widoków.


### Konsola

Zacznijmy od przyjrzenia się jak działa **ORM** na konsoli:

    :::ruby
    Fortune.find_by_id 1
    Fortune.find 1
    Fortune.find 1, 4
    Fortune.find [1, 4]
    f = Fortune.find(1)
    f.update_attributes :updated_at => Time.now, :body => 'Hi!'

### Szablon dla new i edit

Szablon dla metody *edit* różni się
tylko nagłówkiem H1 od szablonu dla *new*.

    :::html_rails app/views/fortunes/edit.html.erb
    <%= title "Edycja fortunki" %>
    <%= form_for @fortune do |f| %>
    <p>
      <%= f.text_area :body %><br>
      <%= f.submit %>
    <p>
    <% end %>

Uwaga: metoda pomocnicza *title* jest zdefiniowana w pliku
*app/helpers/layout_helper.rb* wygenerowanym przez generator
nifty:layout.

Ciekawostka: Napis na przycisku *submit* jest *New Fortune* albo
*Update Fortune*. Jak można to wyjaśnić? Co decyduje
o tym jaki napis jest na przycisku?

I18N: Responders + napis na przycisku Submit. Tłumaczenia
możemy wpisywać w jednym pliku albo w kilku plikach.

Responders:

    :::yaml config/locales/responders.pl.yml
    pl:
      flash:
        actions:
          create:
            notice: '%{resource_name} was successfully utworzono.'
          update:
            notice: '%{resource_name} was successfully uaktualniono.'
          destroy:
            notice: '%{resource_name} was successfully usunięto.'
            alert: '%{resource_name} could not be usunąć.'

Modele:

    :::yaml config/locales/models.pl.yml
    pl:
      helpers:
        submit:
          create: "Utwórz %{model}"
          update: "Zapisz zmiany"


### Szablony częściowe

Generator rozwiązał problem powtórzonego fragmentu kodu 
w naszych szablonach *new* i *edit*:

    :::ruby app/controllers/fortunes_controller.rb
    def new
      @fortune = Fortune.new
    end    

Teraz, jeśli w szablonie dla *new* podmienimy *Fortune.new* na
*@fortune*, to kod formularza będzie taki sam w obu szablonach.

Co to jest refaktoryzacja?

Ciąg dalszy refaktoryzacji: usuwamy kod formularza z szablonów
i przenosimy go do szablonu *_form.html.erb*:

    :::html_rails app/views/fortunes/_form.html.erb
    <%= form_for @fortune do |f| %>
    <p>
      <%= f.text_area :body, :rows => 4 %><br>
      <%= f.submit %>
    <p>
    <% end %>

Zamiast usuniętego kodu wpisujemy w szablonach:

    :::html_rails
    <%= render 'form' %>

Szablon *_form.html.erb* nazywamy szablonem częściowym (ang. *partial template*).

Co to jest zasada DRY – Don’t repeat yourself.
Dlaczego „osuszanie” kodu jest ważne?


## Linkujemy widoki

W wygenerowanych szablonach generator wstawił odsyłacze. 
Na przykład w widoku *index*:

    :::html_rails app/views/fortunes/index.html.erb
    <% @fortunes.each do |fortune| %>
    <p>
     <%= fortune.body %>
     <%= link_to "Edit", edit_fortune_path(fortune) %>
    </p>
    <% end %>
    <p><%= link_to "New Fortune", new_fortune_path %></p>

Wejdźmy na stronę:

    htttp://localhost:3000/fortunes

i sprawdźmy czy linki działają. Klikamy w jakikolwiek link 'Edit'.
Działa?

Przy okazji, zwróćmy uwagę, że metody *update* i *create* nie mają
powiązanych widoków.


### Usuwanie rekordów z tabel

W aktualnej wersji można utworzyć „pustą” fortunkę. Jak? Klikamy link
'New Fortune', następnie przycisk 'New Fortune'. 
Oczywiście nie ma sensu umieszczanie pustych fortunek w bazie.

Na następnym wykładzie zaimplementujemy mechanizm zabezpieczający
przed zapisywaniem pustych fortunek w tabeli *fortunes* (walidacja).

Teraz zajmiemy się usuwaniem pustych fortunek z bazy.

    :::html_rails app/views/fortunes/index.html.erb
    <% @fortunes.each do |fortune| %>
    <p>
     <%= fortune.body %>
     <%= link_to "Edit", edit_fortune_path(fortune) %>
     <%= link_to "Delete", fortune_path(fortune), :confirm = "Are you sure?", :method => :delete %>
    </p>
    <% end %>
    <%= link_to "New Fortune", new_fortune_path %>


### Pozostała tylko implementacja *show*

Został tylko do omówienia widok *show* i powiązana z nim metoda
kontrolera.

    :::html_rails app/views/fortunes/show.html.erb
    <h1>Fortunka #<%= @fortune.id %></h1>
    <p>
      <%= @fortune.body %>
    </p>
    <p><%= link_to "All Fortunes", fortunes_path %></p>

Kontroler:

    :::ruby app/controllers/fortunes_controller.rb
    def show
      @fortune = Fortune.find(params[:id])
      respond_with @fortune
    end

W widoku *index* dopisujemy link:

    :::html_rails app/views/fortunes/index.html.erb
    <%= fortune.body %>
    <%= link_to "Show", fortune_path(fortune) %>

**Inne propozycje olinkowania zasobów?**


## Atom

Dopisujemy do kontrolera (z formatu :js skorzystamy go później):

    respond_to :html, :atom, :js

Widok:

    :::ruby app/views/fortunes/index.atom.builder
    atom_feed do |feed|
      feed.title "Moje Fortunki"
      feed.updated @fortunes.first.updated_at
      @fortunes.each do |fortune|
        feed.entry(fortune) do |entry|
          entry.content fortune.body, :type => "html"
        end
      end
    end

W layout dopisujemy w znaczniku *HEAD*:

    :::html_rails app/views/layouts/application.html.erb
    <%= auto_discovery_link_tag(:atom, fortunes_path(:atom)) %>


## Przechodzimy z Prototype na jQuery

Kopiujemy do katalogu *public/javascripts* plik *rails.js* z:

    http://github.com/rails/jquery-ujs

zmienając jego nazwę na *jquery.rails.js*.

Zmieniamy w layoucie wiersz z *javascript_include_tag* na:

    :::html_rails app/views/layouts/application.html.erb
    <%= javascript_include_tag 
      "http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js", 
      "jquery.rails.js" %> 

i usuwamy z katalogu *public/javascripts* następujące pliki:
*controls.js*, *dragdrop.js*, *effects.js*, *prototype.js* i *rails.js*.

Zamiast zręcznie ręcznie zmieniać źródła możemy skorzystać z generatora
który zrobi to za nas. 

Dopisujemy do *Gemfile*:

    :::ruby Gemfile
    group :development do
      # automate using jQuery: http://github.com/indirect/jquery-rails
      gem 'jquery-rails'
    end

Po wykonaniu polecenia

    rails generate jquery:install


## Routing

Zmieniamy routing tak, aby */fortunes* była stroną główną */*:

    :::ruby config/routes.rb
    # You can have the root of your site routed with "root"
    # just remember to delete public/index.html.
    root :to => "fortunes#index"

I usuwamy statyczną stronę „Welcome aboard”:

    rm public/index.html


## AJAX: dodajemy wyszukiwanie

Co oznacza „unobtrusive Javascript”?

Do szablonu *index.html.erb* dodamy formularz do wyszukiwania
fortunek. Wyszukane fortunki umieścimy w elemencie *DIV*.
Dlaczego potrzebujemy pojemnika na fortunki?

Przy okazji zrobimy refaktoryzację kodu:

    :::html_rails app/views/fortunes/index.html.erb
    <% title "Wszystkie fortunki" %>
    <%= form_tag fortunes_path, :method => :get, :remote => true do %>  
      <p>  
        <%= text_field_tag :search, params[:search] %>  
        <%= submit_tag "Search", :name => nil %>  
      </p>  
    <% end %>  
    <div id="fortunes">
      <%= render @fortunes %>
    </div>
    <p><%= link_to "New Fortune", new_fortune_path %></p>

W szablonie częściowym *_fortune.html.erb* nie potrzebujemy pętli
(dlaczego?):

    :::html_rails app/views/fortunes/_fortune.html.erb
    <p>
     <%= fortune.body %> 
     <%= link_to "Show", fortune_path(fortune) %> | 
     <%= link_to "Edit", edit_fortune_path(fortune) %> |
     <%= link_to "Delete", fortune_path(fortune), :confirm => "Are you sure?", :method => :delete %>
    </p>

Oto fragment źródła strony wygenerowanej z powyższego szablonu:

    :::html_rails
    <form action="/fortunes" data-remote="true" method="get"> 

Do czego służą atrybuty *data-\** ?
Czy elementy z takimi atrybutami się walidują?

Wchodzimy na stronę:

    http://localhost:3000/

Pozostało napisać szablon *index.js.erb*.
Co oznacza rozszerzenie *.js.erb*?

    :::jquery_javascript app/views/fortunes/index.js.erb
    $("#fortunes").html("<%= escape_javascript(render(@fortunes)) %>");

Pytanie: co powinniśmy dopisać / zmienić w kontrolerze
*FortunesController*? Jakąś metodę? Jeśli tak, to jaką?

Odpowiedzi. Zmieniamy kod metody *index*

    :::ruby app/controllers/fortunes_controller.rb
    def index
      @fortunes = Fortune.search(params[:search]).order("created_at desc")
      respond_with @fortunes
    end

A użytą powyżej metodę klasową *search* implementujemy w modelu
*Fortune* tak:

    :::ruby app/models/fortune.rb
    def self.search(query)
      where("body like ?", "%#{query}%")
    end

Metoda *search* jest wykonywana zawsze po wejściu na stronę *index*,
nawet jak nic nie wyszukujemy. Dlaczego nie generuje ona błędu?
Dlaczego wyszukiwanie działa?


## Dodajemy tagowanie

Tagowanie dodamy, korzystając z gemu
[acts-as-taggable-on](http://github.com/mbleigh/acts-as-taggable-on).

Korzystając z tego co napisano w *README.rdoc* dokonujemy
następujących zmian w aplikacji.

Zgodnie z README ze strony git projektu, dopisujemy gem do pliku *Gemfile*:

    :::ruby Gemfile
    gem 'acts-as-taggable-on'

i instalujemy go w systemie za pomocą:

    bundle install

Po instalacji wykonujemy polecenia:

    rails generate acts_as_taggable_on:migration
    rake db:migrate

### Zmiany w kodzie

Do modelu dopisujemy:

    :::ruby app/models/fortune.rb
    class Fortune < ActiveRecord::Base
      acts_as_taggable_on :tags
      ActsAsTaggableOn::TagList.delimiter = " "

Przy okazji, zmieniamy domyślny znak do oddzielania tagów z przecinka
na spację.

W formularzu zmieniamy i dopisujemy:

    :::html_rails app/views/fortunes/_form.html.erb
    <p>Body:<br/><%= f.text_area :body, :cols => 60, :rows => 8 %></p>
    <p><%= f.label :tag_list %>: <%= f.text_field :tag_list, :size => 60 %></p>

a w widoku *index*:

    :::html_rails app/views/fortunes/index.html.erb
    <p>Tags: <%= fortune.tag_list %></p>

Pozsotaje jeszcze dopisać wyświetlanie tagów tu i ówdzie (gdzie?).


### Chmurka tagów

Aby utworzyć chmurkę tagów dopisujemy do widoku *index*:

    :::html_rails app/views/fortunes/index.html.erb
    <% tag_cloud(@tags, %w(css1 css2 css3 css4)) do |tag, css_class| %>
      <%= link_to tag.name, LINK_DO_CZEGO?, :class => css_class %>
    <% end %>

Aby ten kod zadziałał musimy zdefiniować zmienną *@tags*, wczytać kod
metody pomocniczej *tag_cloud*, wystylizować chmurkę tagów oraz
podmienić *LINK_DO_CZEGO?* na coś sensownego.

Na razie możemy wypróbować coś takiego:

    :::html_rails
    <% tag_cloud(@tags, %w(css1 css2 css3 css4)) do |tag, css_class| %>
      <%= link_to tag.name, fortunes_path, :class => css_class %>
      <%= debug(tag) %>
    <% end %>

Jakieś rozwiązanie jest w następnej sekcji.

W metodzie *index* kontrolera *FortunesController* przed dopisujemy:

    :::ruby app/controllers/fortunes_controller.rb
    @tags = Fortune.tag_counts
    respond_with @fortunes  # bez zmian

W pliku na metody pomocnicze dopisujemy;

    :::ruby app/helpers/fortunes_helper.rb
    module FortunesHelper
      include ActsAsTaggableOn::TagsHelper
    end

Na koniec dopisujemy do pliku CSS aplikacji:

    :::css public/stylesheets/application.css
    .css1 { font-size: 1.0em; }
    .css2 { font-size: 1.2em; }
    .css3 { font-size: 1.4em; }
    .css4 { font-size: 1.6em; }


### Dodajemy własne akcje do REST

Mając chmurkę z tagami, wypadałoby olinkować tagi tak, aby
po kliknięciu na nazwę wyświetliły się fortunki otagowane
tą nazwą.

Spróbujemy zrobić to tak. Zaczniemy od routingu:

    :::ruby config/routes.rb
    resources :fortunes do
      collection do 
        get :tags
      end
    end

Sprawdzamy routing:

    rake routes

i widzimy, że mamy dodatkowo:

    tags_fortunes GET /fortunes/tags {:action=>"tags", :controller=>"fortunes"}

Teraz dopisujemy co trzeba w kontrolerze (plus mała refaktoryzacja; jaka?):

    :::ruby app/controllers/fortunes_controller.rb
    before_filter :only => [:index, :tags] do
      @tags = Fortune.tag_counts  # for tag clouds    
    end
    
    def index
      @fortunes = Fortune.search(params[:search]).order("created_at desc")
      respond_with @fortunes
    end
    
    def tags
      @fortunes = Fortune.tagged_with(params[:name])
      render 'index'
    end

Na koniec podmieniamy `LINK_DO_CZEGO?` powyżej:

    :::ruby
    <%= link_to tag.name, tags_fortunes_path(:name=>tag.name), :class => css_class %>

Przyjrzeć się jak to działa!


## Dodajemy komentarze do fortunek

<blockquote>
 <p>Software is invisible and <b>unvisualizable</b>. Geometric abstractions are
  powerful tools. The floor plan of a building helps both architect and
  client evaluate spaces, traffic flows, views. Contradictions and
  omissions become obvious.</p>
 <p>In spite of progress in restricting and simplifying the structures of
  software, they remain inherently unvisualizable, and thus do not
  permit the mind to use some of its most powerful conceptual
  tools. This lack not only impedes the process of design within one
  mind, it severely hinders communication among minds.</p>
 <p class="author">— Frederick P. Brooks, Jr.</p>
</blockquote>

Dodajemy do każdej fortunki możliwość dopisywania komentarzy.

Zaczynamy od wygenerowania rusztowania dla zasobu *Comment* oraz
wykonania migracji:

    rails g resource Comment fortune:references \
        author:string body:string
    rake db:migrate

Zagnieżdżamy zasoby i sprawdzamy jak to zmienia routing:

    :::ruby
    resources :fortunes do
      resources :comments
      collection do 
        get :tags
      end
    end

Po tej zmianie polecenie

    rake routes

wypisuje nowy routing:
 
                         GET    /fortunes/:fortune_id/comments          {:action=>"index",   :controller=>"comments"}
        fortune_comments POST   /fortunes/:fortune_id/comments          {:action=>"create",  :controller=>"comments"}
     new_fortune_comment GET    /fortunes/:fortune_id/comments/new      {:action=>"new",     :controller=>"comments"}
                         GET    /fortunes/:fortune_id/comments/:id      {:action=>"show",    :controller=>"comments"}
                         PUT    /fortunes/:fortune_id/comments/:id      {:action=>"update",  :controller=>"comments"}
         fortune_comment DELETE /fortunes/:fortune_id/comments/:id      {:action=>"destroy", :controller=>"comments"}
    edit_fortune_comment GET    /fortunes/:fortune_id/comments/:id/edit {:action=>"edit",    :controller=>"comments"}


oraz stary routing, który też obowiązuje:

    tags_fortunes GET    /fortunes/tags     {:action=>"tags",    :controller=>"fortunes"}
                  GET    /fortunes          {:action=>"index",   :controller=>"fortunes"}
         fortunes POST   /fortunes          {:action=>"create",  :controller=>"fortunes"}
      new_fortune GET    /fortunes/new      {:action=>"new",     :controller=>"fortunes"}
                  GET    /fortunes/:id      {:action=>"show",    :controller=>"fortunes"}
                  PUT    /fortunes/:id      {:action=>"update",  :controller=>"fortunes"}
          fortune DELETE /fortunes/:id      {:action=>"destroy", :controller=>"fortunes"}
     edit_fortune GET    /fortunes/:id/edit {:action=>"edit",    :controller=>"fortunes"}
    
             root        /                  {:controller=>"fortunes", :action=>"index"}

Przechodzimy do modelu *Comment*, gdzie znajdujemy dopisane powiązanie:

    :::ruby app/models/comment.rb
    class Comment < ActiveRecord::Base
      belongs_to :fortune
    end

Przechodzimy do modelu *Fortune*, gdzie dopisujemy drugą stronę powiązania:

    :::ruby app/models/fortune.rb
    class Fortune < ActiveRecord::Base
      has_many :comments
      ...

Nie zapominamy o migracji:

    rake db:migrate

Jeśli na konsoli uruchomimy kod:

    :::ruby
    Fortune.first.comments  #=> []

to przekonamy się, że komentarze pierwszej fortunki tworzą pustą tablicę.
Aby dodać komentarz możemy postąpić tak:

    :::ruby
    Fortune.first.comments << Comment.new(:author=>"Ja", :body=>"Fajne!")


### Gdzie wyświetlać komentarze?

Komentarze dla konkretnej fortunki wypiszemy w jej widoku *show* 
(**inne propozycje?**). Dopiszemy taki kod:

    :::html_rails app/views/fortunes/show.html.erb
    <% if @fortune.comments.any? %>
      <h2>Komentarze</h2>
      <% @fortune.comments.each do |comment| %>
       <p>Autor:<br><%= comment.author %></p>
       <div class="comment">
         <b>Body:</b> <%= comment.body %>
       </div>
       <%= link_to "Delete", [@fortune, comment], :confirm => "Are you sure?", :method => :delete %>
      <% end %>
    <% end %>

Jakie nowe rzeczy pojawiły się powyższym kodzie?


### Gdzie wpisywać nowe komentarze?

Najwygodniej byłoby dodać też formularz do widoku *show*
(**dlaczego?**):

    :::html_rails app/views/fortunes/show.html.erb
    <h2>Dodaj komentarz</h2>
    <%= form_for [@fortune, @fortune.comments.build] do |f| %>
      <%= f.error_messages %>
      <p>
        <%= f.label :author, "Author" %><br>
        <%= f.text_field :author %>
      </p>
      <p><%= f.text_area :body, :rows => 4 %></p>
      <p><%= f.submit %></p>
    <% end %>

Nowe rzeczy w kodzie? Dlaczego taki pokrętny kod: **@fortune.comments.build**?
Czy samo *Comment.new* nie wystarczy?
Gdzie jest zdefiniowana metoda *error_messages*?


### Tworzenie i usuwanie komentarzy

W pustym *CommentsController* wpisujemy:

    :::ruby app/controllers/comments_controller.rb
    class CommentsController < ApplicationController
      before_filter do
        @fortune = Fortune.find params[:fortune_id]
      end

      def new
        respond_with @comment
      end

      def create
        @comment = @fortune.comments.new params[:comment]
        @comment.save
        respond_with @comment, :location => fortunes_url
      end

      def destroy
        @comment = @fortune.comments.find params[:id]
        @comment.destroy
        respond_with @fortune
      end
    end

Dodajemy nowy widok *new* dla komentarzy (dlaczego?):

    :::html_rails app/views/comments/new.html.erb
    <% title "Nowy komentarz" %>
    <%= render 'form' %>
    <%= link_to 'Back', fortunes_path %>


### Refaktoryzacja widoku „show” dla fortunek

Tworzymy dwa szablony częściowe dla komentarzy: *_form.html.erb*:

    :::html_rails app/views/comments/_form.html.erb
    <%= form_for [@fortune, @fortune.comments.build] do |f| %>
      <%= f.error_messages %>
      <p>
        <%= f.label :author, "Author" %><br>
        <%= f.text_field :author %>
      </p>
      <p><%= f.text_area :body, :rows => 4 %></p>
      <p><%= f.submit %></p>
    <% end %>

oraz *_comment.html.erb*::

    :::html_rails app/views/comments/_comment.html.erb
    <p>Autor:<br><%= comment.author %></p>
    <div class="comment">
      <b>Body:</b> <%= comment.body %>
    </div>
    <%= link_to "Delete", [comment.fortune, comment], :confirm => "Are you sure?", :method => :delete %>

Interesujący kod w *link_to* powyżej!

Poprawiamy kod widoku *show*, tak aby korzystał z tych szablonów:

    :::html_rails app/views/fortunes/show.html.erb
    <h2>Dodaj komentarz</h2>
    <%= render 'comments/form' %>
    
    <% if @fortune.comments.any? %>
      <h2>Komentarze</h2>
      <%= render @fortune.comments %>
    <% end %>


## I18N: error_messages

Kod wygenerowany przez generator nifty:layout:

    :::ruby app/helpers/error_messages_helper.rb
    module ErrorMessagesHelper
      # Render error messages for the given objects. The :message and :header_message options are allowed.
      def error_messages_for(*objects)
        options = objects.extract_options!
        options[:header_message] ||= "Invalid Fields"
        options[:message] ||= "Correct the following errors and try again."
        ...

Jak to zlokalizować? Jaki dodać prefix? Zobacz 
[Support Rails built in i18n system for easy translations](http://github.com/ryanb/nifty-generators/issues#issue/22).

Może tak:

    :::ruby 
    options[:header_message] ||= I18n.t(errors.template.header_message), :default => "Invalid Fields"
    options[:message] ||= I18n.t(errors.template.message), :default => "Correct the following errors and try again."

Plik z polskim tłumaczeniem:

    errors:
      template:
        header_message: 
          "Nieprawidłowo wypełniony formularz"
        message: 
          "Popraw poniższe błędy i spróbuj jeszcze raz:"


## TODO

Fortunka jest niechlujnie olinkowana: gdzieniegdzie brakuje odsyłaczy,
a w innych miejscach jesteśmy odsyłani w maliny.


## Różne

* Co to jest „unobtrusive Javascript”?
  [jQuery UJS dla Rails3](http://github.com/rails/jquery-ujs).
* Zajaxowana Fortunka: sklonować repozytorium git *hello/rails3-ajax*.
  Jak to działa? Źródło 
  [Creating a 100% ajax CRUD using rails 3 and unobtrusive javascript](http://stjhimy.com/posts/7).
* Bundler. Gemfile examples 
  [Featuring Bundler, Cucumber, RVM, Postgres, on Ruby-1.8.7](http://gist.github.com/416372)
* [Rails3 blog w 20 minut] [rails3 blog]


[rvm]: http://rvm.beginrescueend.com/ "Ruby Version Manager"
[rails3 blog]: http://www.railsdispatch.com/posts/rails-3-makes-life-better "Rails3 blog w 20 minut"
